--- 
title: "Credibility of a repertoire report"
author: ""
date: "Updated: `r date()`"
knit: "bookdown::render_book"
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "Analysis notebook"
output:
    bookdown::gitbook:
      css: repcred.css 
      config:  
         fig_caption: yes
         toc:
            scroll_highlight: yes
            collapse: subsection
            depth: 4            
         download: yes
         sharing: no
         keep_md: true
params:
   date: !r date()
   echo:  FALSE
   cache: FALSE
   rep:  !r system.file("extdata/P4_I1.tsv", package = "repcred")
   outdir: !r tempdir()
   genome_file: !r NA
   full_or_basic: !r FALSE
   downsample: !r TRUE
---

```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  fig.width = 7,
  fig.asp = 0.7,
  echo = params$echo,
  cache = params$cache,
  warning = FALSE,
  message = FALSE,
  out_dir = params$outdir,
  eval.opts = c('eval', 'echo', 'fig.height', 'fig.width')
)

# Save params to an .RData file. Useful for debugging.
save(params, file = file.path(params$outdir, "params.RData"))

# Load libraries
library(repcred)
library(airr)
library(sumrep)
library(plotly)
library(stringr)
library(ggplot2)
library(data.table)
library(seqinr)
library(kableExtra)

# Configuration and default values
gene_data = NA

#Below variables are set to give the orange , green and red colours. These colours were used as it makes the text easier to read and are more muted than the regular red , orange and green.
green = "LightGreen"
amber = "NavajoWhite"
red = "pink"

sections = 20
progress = 0
```

#  Input parameters 

```{r section1}
#SECTION 1
# if (is.na(params$genome_file)) {
#   germline_reference = NULL
# } else{
#   germline_reference <-
#     tigger::readIgFasta(params$genome_file)
# }
print(params$genome_file)
germline_reference = NULL

if (params$full_or_basic == "Full sumrep stats") {
  full_check = TRUE
} else{
  full_check = FALSE
}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections

params
```


```{r section2, warning=FALSE}
repertoire <- data.table::fread(params$rep)
# Downsampling unless check box unticked
num_keep <- 5000
if (params$downsample & nrow(repertoire) > num_keep) {
  repertoire <- repertoire[sample(nrow(repertoire), size = num_keep),]
}


#Set up section colours
section_1 = green
section_2 = green
section_3 = green
section_4 = green
section_5 = green
section_6 = green
section_7 = green
section_8 = green
section_9 = green
section_10 = green
section_11 = green

if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```
# Quality Control Stats

```{r section3, warning=TRUE,results="asis"}
#SECTION 2
is_compliant <-
  suppressWarnings(airr::validate_rearrangement(repertoire)) # TODO: consider if to display the warning

if (!is_compliant) {
  formattedErrorMeassage("The repertoire is not AIRR compliant. Exiting analysis.")
  knitr::knit_exit()
}

missing_columns <- findMissingColumns(repertoire)
if (length(missing_columns) > 0) {
  writeLines("<h3> Columns with missing / No data </h3> ")
  kbl(data.table(column_name = missing_columns))
}

if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```


# Non-nucleotides in sequence

```{r section4, warning=FALSE}
#SECTION 3
print(check_nucleotides(repertoire)) # TODO: this works only on the sequence column. If missing, should it be changed to sequence_alignment?
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```

# Statistics
This section provides useful statistics about the repertoire:

### Productive vs. non-productive sequences

```{r section5, fig.cap= "The number of productive and non productive sequences. The x-axis is the productive definition, and the y-axis is the abdunce count.",warning=TRUE}
#SECTION 4
repertoire$productive <- as.logical(repertoire$productive)
prod_info <- data.table("Category"=factor(repertoire$productive, 
                               levels = c("TRUE","FALSE")))
non_prod <- any(!repertoire$productive)

vj_column <- "vj_in_frame" %in% colnames(repertoire)&!any(is.na(repertoire$vj_in_frame))

p <- ggplot2::ggplot(
  prod_info, 
  aes(x = !!as.name("Category"))) +
  ggplot2::geom_bar(stat="count") + 
  ggpubr::theme_pubclean() +
  ggplot2::labs(x = "", y = "Occurences") +
  ggplot2::scale_x_discrete(drop = FALSE, labels=c("Productive", "Non-productive", "NA/Not specified"))

plot(p)
knitr::kable(prod_info %>% 
      dplyr::count(!!as.name("Category"), name = "Occurences", .drop = F) %>% 
      dplyr::mutate("Category" = as.character(!!as.name("Category")),
                    "Category" =  dplyr::recode(!!as.name("Category"),"TRUE"="Productive",
                                             "FALSE"="Non-productive"),
                    "Category" = tidyr::replace_na(!!as.name("Category"),"NA/Not specified")))

if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections

```

`r  if(vj_column){"### Percentage of sequences where the V and J region are in-frame"}`

```{r section6, eval=vj_column,comment=NA,results="asis"}
writeLines(paste0("Retrived information from the vj_in_frame column, precentage of V-J seuqences in frame: ",formatC(mean(as.logical(repertoire$vj_in_frame))*100,digits = 5),"%"))
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections

```
`r  if(non_prod){"### Non-productive sequences breakdown"}`

```{r section7, fig.cap= "A breakdown of the type of non-productive sequences. The x-axis is the non-productive type, and the y-axis is the abdunce count. The red color represents sequences that has both a stop codon and the V-J is not in frame, gray color represents sequences that are in either types.", warning=TRUE, eval=non_prod}
### table the columns that indicate non-productive sequences.

cols <- c("vj_in_frame","stop_codon")

## check the cols are booleans. If not change

repertoire[[cols[1]]] <- if(is.logical(repertoire[[cols[1]]])) repertoire[[cols[1]]] else as.logical(repertoire[[cols[1]]])
repertoire[[cols[2]]] <- if(is.logical(repertoire[[cols[2]]])) repertoire[[cols[2]]] else as.logical(repertoire[[cols[2]]])

prod_info <- repertoire[!repertoire$productive, .SD, .SD=cols] %>% 
  dplyr::mutate(vj_not_frame = !(!!as.name("vj_in_frame")),
                both = (!!as.name("vj_not_frame")) & (!!as.name("stop_codon")) ) %>%
  dplyr::select(!!as.name("vj_not_frame"),!!as.name("stop_codon"),!!as.name("both")) %>%
  dplyr::summarise("both_stop_codon" = sum(!!as.name("both")),
                   "only_stop_codon" = sum(!!as.name("stop_codon"))-(!!as.name("both_stop_codon")),
                   "both_vj_not_frame" = sum(!!as.name("both")),
                   "only_vj_not_frame" =  sum(!!as.name("vj_not_frame"))-(!!as.name("both_vj_not_frame")),
                   "Unkown" = sum(!(!!as.name("stop_codon"))& !(!!as.name("vj_not_frame")))) %>%
  tidyr::gather(key = "Category", value="Occurences") %>%
  dplyr::mutate("Both" = grepl("both",!!as.name("Category")),
                "Category" = gsub("(both|only)_","",!!as.name("Category")))
prod_info$Category <- factor(prod_info$Category, levels = c("vj_not_frame","stop_codon","Unkown"))
ggplot2::ggplot(
  prod_info, 
  ggplot2::aes(x = !!as.name("Category"), fill = !!as.name("Both"))) +
  ggplot2::geom_bar(stat="count") + 
  ggpubr::theme_pubclean() +
  ggplot2::labs(x = "", y = "Occurences", fill = "V-J out of frame and stop codon") +
  ggplot2::scale_fill_manual(values = c("gray50","firebrick")) + 
  ggplot2::scale_x_discrete(drop = FALSE, 
                            labels=c("V-J out of frame", 
                                     "Contains stop codons", 
                                     "Unkown"))

knitr::kable(data.frame("Category" = c("Contains stop codons",
                          "V-J out of frame",
                          "V-J out of frame and stop codon",
                          "Unkown"),
           "Occurences" = c(prod_info$Occurences[prod_info$Category=="stop_codon" & !prod_info$Both],
                            prod_info$Occurences[prod_info$Category=="vj_not_frame" & !prod_info$Both],
                            prod_info$Occurences[prod_info$Category=="stop_codon" & prod_info$Both],
                            prod_info$Occurences[prod_info$Category=="Unkown"])) %>% 
      dplyr::mutate("Category" = as.character(!!as.name("Category")),
                    "Category" =  dplyr::recode(!!as.name("Category"),"vj_not_frame"="V-J out of frame",
                                             "stop_codon"="Contains stop codons")))
```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```


### Sequence length distribution

```{r section8, fig.cap="The sequences length distribution. The x-axis is the binned sequence lengths, and the y-axis is the frequency.", warning=FALSE,results="asis"}


length_info <- data.frame(region = c(rep("Input sequence",nrow(repertoire)),
                                     rep("V(D)J sequence",nrow(repertoire))),
                          lengths = c(nchar(repertoire$sequence),
                                      nchar(gsub("[.]","",repertoire$sequence_alignment))))

ggplot2::ggplot(
  length_info, 
  aes(x = !!as.name("lengths"))) +
  ggplot2::geom_histogram(bins = 30) + 
  ggpubr::theme_pubclean() +
  ggplot2::labs(x = "", y = "Frequency") +
  ggplot2::facet_grid(cols = vars(!! sym("region")))
  

length_info <- length_info %>% dplyr::group_by(!!as.name("region")) %>%
  dplyr::summarise(
    Min = min(!!as.name("lengths")),
    Max = max(!!as.name("lengths")),
    Mean = mean(!!as.name("lengths")),
    Median = median(!!as.name("lengths")),
    SD = sd(!!as.name("lengths")),
    "q5" = quantile(!!as.name("lengths"), probs = c(0.05)),
    "q95" = quantile(!!as.name("lengths"), probs = c(0.95)),
  )
knitr::kable(length_info)
```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```

# Annotation Calls Statistics

```{r section9}
v_usage_info <- getGeneAlleleStat(repertoire, reference = germline_reference, call = "v_call")
d_usage_info <- getGeneAlleleStat(repertoire, reference = germline_reference, call = "d_call")
j_usage_info <- getGeneAlleleStat(repertoire, reference = germline_reference, call = "j_call")

appearance_info <- dplyr::bind_rows(v_usage_info$gene_data,
                             d_usage_info$gene_data,
                             j_usage_info$gene_data)

appearance_info$segment <- substr(appearance_info$gene,1,4)
```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```

## Number of unique allele calls per gene

```{r section10, warning=TRUE, fig.subcap=c("Unique allele calls per gene. Each row is a different gene segment (V/D/J). The x-axis is the different genes, and the y-axis is the count."),results="asis"}
segments <- length(unique(appearance_info$segment))
size <- max(table(appearance_info$segment))
g <- ggplot2::ggplot(appearance_info, 
  ggplot2::aes(x = !!as.name("gene"), y = !!as.name("count_unique_alleles"))) +
  ggplot2::geom_col() + 
  ggpubr::theme_pubclean() +
  #ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  ggplot2::labs(x = "", y = "# of unique alleles") +
  ggplot2::facet_wrap(vars(!! sym("segment")), nrow = 1, 
                      ncol = segments,
                      scales = "free") + coord_flip()

subchunkify(g, fig_height=size, fig_width=size/3)
```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```

## Relative usage

```{r section11, fig.height=size, warning=TRUE, fig.subcap=c("Gene usage. Each row is a different gene segment (V/D/J). The x-axis is the different genes, and the y-axis is the relative usage."),results="asis"}

usage_info <- appearance_info %>%
  dplyr::group_by(!!as.name("segment")) %>%
  dplyr::mutate(n = sum(!!as.name("frequency"))) %>%
  dplyr::group_by(!!as.name("segment"),!!as.name("gene")) %>%
  dplyr::summarise("fraction" = !!as.name("frequency")/unique(!!as.name("n")))

segments <- length(unique(usage_info$segment))
size <- max(table(usage_info$segment))
g <- ggplot2::ggplot(usage_info, 
  ggplot2::aes(x = !!as.name("gene"), y = !!as.name("fraction"))) +
  ggplot2::geom_col() + 
  ggpubr::theme_pubclean() +
  #ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  ggplot2::labs(x = "", y = "Relative usage") +
  ggplot2::facet_wrap(vars(!! sym("segment")), nrow = 1, 
                      ncol = segments,
                      scales = "free") + coord_flip()

subchunkify(g, fig_height=size, fig_width=size/3)

```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```

```{r section12, warning=TRUE,results="asis"}
# TODO: missing primers, gene frequency. 

## get gene usage. Get the genes with alakazam getGene and calculate the relative usage. If germline is supplied. Display only genes within the germline. Else show all.
# 
# usage_info <- repertoire %>% rowwise() %>%
#   mutate(v_gene = getGene(!!as.name("v_call"), ))
# 
# 
# usage_info <- getGeneAlleleStat(repertoire, reference = germline_reference, call = "v_call")
# 
# ## unique genes and alleles.
# 
# ggplot2::ggplot(
#   data.frame("Category" = c("Unique Genes","Unique Alleles"), 
#                   "Counts" = c(nrow(usage_info$gene_data[usage_info$gene_data$frequency>0,]),
#                                nrow(usage_info$allele_data[usage_info$allele_data$frequency>0,]))), 
#   ggplot2::aes_string(x = "Category", y = "Counts")) +
#   ggplot2::geom_col() + 
#   ggpubr::theme_pubclean() +
#   ggplot2::labs(x = "", y = "Counts")
# 
# ## Allele counts. If reference is supplied showing the zeros?
# 
# ggplot2::ggplot(usage_info$allele_data[usage_info$allele_data$frequency>0,],
#                 ggplot2::aes_string(x="allele",y="frequency" ,fill="frequency")) + 
#   ggplot2::geom_col() + 
#   ggplot2::guides(fill = "none") + 
#   ggpubr::theme_pubclean() +
#   ggplot2::labs(x="Alleles",y="Number of occurences") + coord_flip()
# 
# fasta_genes <- readInGeneNamesIMGTFasta(gene_data)
# gene_freq_table = geneCount(genes_present,fasta_genes)
# freq_data_table=gene_freq_table
# gene_freq_table=gene_freq_table[gene_freq_table$gene_count>0,]
# gene_tables=getUniqueGenes(gene_freq_table)
# genes_only_freq_table = gene_tables[[1]]
# 
# cat("\n")
# print(kable(gene_freq_table))
# cat("\n")
# 
# number_unqiue_alleles = length(gene_freq_table$gene_name)
# number_unqiue_genes = length(genes_only_freq_table$gene_name)
# labels=c("Number of unique alleles" , "Number of unique genes")
# values=c(number_unqiue_alleles,number_unqiue_genes)
# 
# barplot(values,names.arg = labels,col='light blue',ylab="Counts" ,main="Comparison of unique genes to unique alleles" )
# print(number_unqiue_genes)
# print(ggplot(gene_freq_table,aes(x=gene_name,y=gene_count ,fill=gene_count))+geom_bar(stat="identity")+guides(fill = "none")+labs(x="Gene",y="Number of occurences")+coord_flip())
# 
# 
# cat("\n")
# print(kable(gene_tables[[1]]))
# cat("\n")
# allele_link=gene_tables[[2]]
# gene_allele_freq_table=data.frame(table(allele_link$gene,allele_link$allele))
# gene_allele_freq_table = gene_allele_freq_table[gene_allele_freq_table$Freq>0,]
# gene_allele_freq_table$Var1 <- as.factor(gene_allele_freq_table$Var1)
# print(ggplot(gene_allele_freq_table,aes(x=Var1,y=Freq,fill=Var2))+geom_bar(stat="identity")+guides(fill = "none", x=guide_axis(angle=90))+labs(x="Gene",y="Number of alleles present"))
# 
# cat("\n")
# print(kable(allele_link))
# cat("\n")
# 
# writeLines("<h3>Genes not present in the repertoire:</h3>")
# print(kable(getAbsentGeneList(freq_data_table)))

```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```

# General Sumrep Statistics

```{r section13, warning=TRUE,results="asis"}

### summrep statistics graphs = hot/cold spots, GC content, Mutation and germline

### hot cold, and GC based on the sequence_alignment column

hot_data <- sumrep::getHotspotCountDistribution(repertoire)
cold_data <- sumrep::getColdspotCountDistribution(repertoire)
gc_data <- sumrep::getGCContentDistribution(repertoire)

sumrep_info <- data.frame(
  "Category" = c(rep("HotSpot",length(hot_data)),
                 rep("ColdSpot",length(cold_data)),
                 rep("GC content",length(gc_data))),
  "values" = c(hot_data,cold_data,gc_data)
)

sumrep_info$Category <- factor(sumrep_info$Category, levels = c("HotSpot","ColdSpot","GC content"))

#SECTION 6
plot(0:1,xaxt='n',yaxt='n',ann=FALSE)
legend("center",c("Mean +- standard dev","5% and 95% quantile points","Min and Max Value points"),fill=c("Dark blue","light blue","red"))

if("sequence_alignment" %in% colnames(repertoire)&!any(is.na(repertoire$sequence_alignment))){
hotspotCountDist(repertoire)
coldspotCountDist(repertoire)
gcContentDistribution(repertoire)
}else{
   section_6 = amber
    writeLines("Missing column : sequence_alignment \n Unable to run statistics : getHotspotCountDistribution , getColspotCountDistribution, getGCContentDistribution")
}


if("sequence_alignment" %in% colnames(repertoire) & "germline_alignment" %in% colnames(repertoire) &  !any(is.na(repertoire$sequence_alignment))& !any(is.na(repertoire$germline_alignment))){
 positionDistancesBetweenMutationDistribution(repertoire)
 distanceFromGermlineToSequenceDistribution(repertoire)  
}else{
   if(section_6 == amber){
      section_6 = red
   }else{
      section_6 = amber
   }
   writeLines("Missing columns : sequence_alignment , germline_alignment  \n Unable to run statistics : positionDistancesBetweenMutationDistribution , distanceFromGermlineToSequenceDistribution")
}

```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```


#  Pairwise Statistics

```{r section14, warning=TRUE,results="asis"}
#SECTION 7
if(isTRUE(full_check)){
 plot(0:1,xaxt='n',yaxt='n',ann=FALSE)
legend("center",c("Mean +- standard dev","5% and 95% quantile points","Min and Max Value points"),fill=c("Dark blue","light blue","red"))

if("sequence_alignment" %in% colnames(repertoire)&!any(is.na(repertoire$sequence_alignment))){
CDR3pairwiseDistanceInfo(repertoire)
pairwiseDistDistribution(repertoire)
#nearestNeighbourDistInfo(repertoire) ## TODO: takes to long to run.
}else{
   section_7 = red
   writeLines("Missing column : Sequence_alignment \n Unable to run statistics")
}
}else{
   writeLines("Only the basic statistics were run.Please see other sections for the other statistics.")
}


```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```


#  Physiochemical Statistics

```{r section15}
if (all(is.na(repertoire$junction_aa))) {
    print("Skipping this section: `juncation_aa` is empty.")
}
```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```


```{r section16, warning=TRUE,results="asis",eval=!all(is.na(repertoire$junction_aa))}
#SECTION 8
plot(0:1,xaxt='n',yaxt='n',ann=FALSE)
legend("center",c("Mean +- standard dev","5% and 95% quantile points","Min and Max Value points"),fill=c("Dark blue","light blue","red"))


#polarityDistribution(repertoire)
#aromaticityDistribution(repertoire)
#acidityDistribution(repertoire)
#basicityDistribution(repertoire)
# bulkinessDistribution(repertoire)
# chargeDistribution(repertoire)
aliphaticDistribution(repertoire)
print(mean(getAliphaticIndexDistribution(repertoire)),nm.rm=TRUE)
GRAVYDistribution(repertoire)

```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```


#  Insertion Length Distributions

```{r section17, warning=TRUE,results="asis"}
#SECTION 9
plot(0:1,xaxt='n',yaxt='n',ann=FALSE)
legend("center",c("Mean +- standard dev","5% and 95% quantile points","Min and Max Value points"),fill=c("Dark blue","light blue","red"))
if("np1_length" %in% colnames(repertoire)&!any(is.na(repertoire$np1_length))){
 VJinsertionLengthDistribution(repertoire)
 VDinsertionLengthDistribution(repertoire)
}else{
 writeLines("Missing Column : np1_length")  
}
if("np2_length" %in% colnames(repertoire)&!any(is.na(repertoire$np2_length))){
DJinsertionLengthDistribution(repertoire)
}else{
   writeLines("Missing Column : np2_length")  
}
```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```


#  Prime deletion Distributions Statistics

```{r section18, warning=TRUE,results="asis"}
#SECTION 10

plot(0:1,xaxt='n',yaxt='n',ann=FALSE)
legend("center",c("Mean +- standard dev","5% and 95% quantile points","Min and Max Value points"),fill=c("Dark blue","light blue","red"))

missing_col_count = 0
##
if("v_3p_del" %in% colnames(repertoire)&!any(is.na(repertoire$v_3p_del))){
 VGene3PrimeDeletionLengthDistribution(repertoire)  
missing_col_count = missing_col_count +1
}else{
   writeLines("\n Missing column : v_3p_del , Cannot run statistic \n")
}
if("v_5p_del" %in% colnames(repertoire)&!any(is.na(repertoire$v_5p_del))){
 VGene5PrimeDeletionLengthDistribution(repertoire) 
   missing_col_count = missing_col_count +1
}else{
   writeLines("Missing column : v_5p_del , Cannot run statistic \n")
}
##
if("d_3p_del" %in% colnames(repertoire)&!any(is.na(repertoire$d_3p_del))){
DGene3PrimeDeletionLengthDistribution(repertoire)
   missing_col_count = missing_col_count +1
}else{
   writeLines("Missing column : d_3p_del , Cannot run statistic \n")
}
if("d_5p_del" %in% colnames(repertoire)&!any(is.na(repertoire$d_5p_del))){
DGene5PrimeDeletionLengthDistribution(repertoire)
   missing_col_count = missing_col_count +1
}else{
   writeLines("Missing column : d_5p_del , Cannot run statistic \n")
}
##
if("j_3p_del" %in% colnames(repertoire)&!any(is.na(repertoire$j_3p_del))){
JGene3PrimeDeletionLengthDistribution(repertoire)
   missing_col_count = missing_col_count +1
}else{
   writeLines("Missing column : j_3p_del , Cannot run statistic \n")
}
if("j_5p_del" %in% colnames(repertoire)&!any(is.na(repertoire$j_5p_del))){
JGene5PrimeDeletionLengthDistribution(repertoire)
   missing_col_count = missing_col_count +1
}else{
   writeLines("Missing column : j_5p_del , Cannot run statistic \n")
}

if(missing_col_count > 3){
   section_10=red
}
if(missing_col_count > 0){
   section_10=amber
}
```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```


#  Possible Chimerisms
Below table shows the comparison between the total number of sequences compares to the total number of unique CDR3 sequences and then compared to the number of CDR3 sequences that have multiple different v-call genes associated with them.
```{r section19, CDR3_Chimera_Check, warning = TRUE ,fig.width=9}
#SECTION 11
if(full_check == TRUE){
repertoire = repertoire[!is.na(repertoire$sequence),]
cdr3_seq_info = checkCDR3(repertoire)

#table(cdr3_seq_info$cdr3_seq)
cdr3_vcalls = getVCalls(cdr3_seq_info,repertoire,FALSE)
total_num_unique_seq = length(unique(repertoire$sequence))
##
num_uniq_cdr3_seq = length(unique(cdr3_seq_info$cdr3_seqs))

num_occur_multiple_gene_call <- length(which(data.frame(table(cdr3_seq_info$cdr3_seqs))$Freq > 1))
#kbl(cdr3_vcalls)

####
# 
 freq_table= data.frame(table(as.character(cdr3_vcalls$seq),as.character(cdr3_vcalls$v_call_genes)))
 freq_table= freq_table[freq_table$Freq >1,]
multiple_vgene_freq = data.frame(table(as.character(freq_table$Var1)))
multiple_vgene_freq = multiple_vgene_freq[multiple_vgene_freq$Freq>1,]
multiple_gene_calls = length(table(freq_table$Var1))
#print(freq_table)
seqs_stats_vals=c(total_num_unique_seq,num_uniq_cdr3_seq,multiple_gene_calls)
labels = c("Unique complete seqs" , "Unique CDR3 seqs" , "Unique CDR3 seqs with multiple single v-calls" )

##
par(mar=c(8, 13 ,5 ,3))
barplot(seqs_stats_vals,names.arg = labels,col='dark blue',xlab="Occurences" ,main="CDR3 Sequence comparisons", las=2, horiz=TRUE ,cex.names=0.8)


freq_table$Var2 <- as.factor(freq_table$Var2)
ggplot(freq_table,aes(x=Var2,y=Freq,fill=Var1))+geom_bar(stat="identity")+guides(
  #fill = "none", 
  x=guide_axis(angle=90))+labs(x="Gene",y="Number of sequences present")
}else{
   writeLines("Only Basic stats were run , if you would like to get stats of possible chimeric sequences please run full stats.")
   section_11 = "DarkGrey"
}
```
```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```


Below contain CDR3 sequences with more than one v_call:

```{r section20, warning = TRUE, results="asis" } 
options(width = 2000)
num_to_display=0
if(length(repertoire$sequence)>100000){
   num_to_display = 3
}else{
   num_to_display = 6
}

# if(seq_type == "")
# display_type
#if (full_check == TRUE){
plotVgeneDist(cdr3_vcalls,num_to_display, "aa",multiple_vgene_freq)#}
#kbl(most_chimeric)
```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```

```{r section21, warning = TRUE, results="asis"}
#kbl(as.data.table(findAmplificationAreas(repertoire)))

addTrafficLighting(c(section_1,section_2,section_3,section_4,section_5,section_6,section_7,section_8,section_9,section_10,section_11))
```

```{r, warning=FALSE}
if (shiny::isRunning())
  progress = progress + 1/sections
  shiny::setProgress(progress)  # set progress to 1/sections
```



